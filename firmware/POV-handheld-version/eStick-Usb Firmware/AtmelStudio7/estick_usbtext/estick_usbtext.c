#include <util/delay.h> 


#include "config.h"
#include "usb_drv.h"
#include "usb_task.h"
#include "wdt_drv.h"
#include "power_drv.h"
#include "usb_standard_request.h"
#include <avr/eeprom.h>


void hid_task_init(void);
int hid_task(void);


//_____ M A C R O S ________________________________________________________

#ifndef F_CPU
  #define F_CPU 8000000 
#endif

#define DELAYTIME 280
#define CHAR2CHAR_TIME 15000 
#define CHARWIDTH 7 
#define CHARCOUNT 50

#define DISPLENGTH  5
#define SCROLLSPEED 6
#define MAXLEN 510


/* Constant Array Declaration to refelect the fonts
 * Note: All LEDs are low active, hence, the font
 *       maps are generated in an inverted fashion.
 *
 * The following table was generated with an OpenOffice Calc file (fontgen.ods) 
 * that is also made available for MS Excel 2003 (the latter, however, requires 
 * that the optional "Analysis ToolPak add-in" is installed - available during 
 * the standard installation.)
 */
unsigned char characters [CHARCOUNT][CHARWIDTH]  =
{
 {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},  //SPACE 0
 {0xFF, 0x80, 0x77, 0x77, 0x77, 0x80, 0xFF},  //A 1
 {0xFF, 0x00, 0x6E, 0x6E, 0x6E, 0x91, 0xFF},  //B 2
 {0xFF, 0x81, 0x7E, 0x7E, 0x7E, 0x7E, 0xFF},  //C 3
 {0xFF, 0x00, 0x7E, 0x7E, 0x7E, 0x81, 0xFF},  //D 4
 {0xFF, 0x00, 0x6E, 0x6E, 0x6E, 0x7E, 0xFF},  //E 5
 {0xFF, 0x00, 0x6F, 0x6F, 0x6F, 0x7F, 0xFF},  //F 6
 {0xFF, 0x81, 0x7E, 0x76, 0x76, 0xB1, 0xFF},  //G 7
 {0xFF, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xFF},  //H 8
 {0xFF, 0xFF, 0x7E, 0x00, 0x7E, 0xFF, 0xFF},  //I 9
 {0xFF, 0xFD, 0xFE, 0xFE, 0xFE, 0x01, 0xFF},  //J 10
 {0xFF, 0x00, 0xEF, 0xEF, 0xD7, 0x38, 0xFF},  //K 11
 {0xFF, 0x01, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF},  //L 12
 {0xFF, 0x00, 0xBF, 0xDF, 0xBF, 0x00, 0xFF},  //M 13
 {0xFF, 0x00, 0x9F, 0xE7, 0xF9, 0x00, 0xFF},  //N 14
 {0xFF, 0x81, 0x7E, 0x7E, 0x7E, 0x81, 0xFF},  //O 15
 {0xFF, 0x00, 0x77, 0x77, 0x77, 0x9F, 0xFF},  //P 16
 {0xFF, 0x81, 0x7E, 0x7A, 0x7D, 0x82, 0xFF},  //Q 17
 {0xFF, 0x00, 0x77, 0x77, 0x73, 0x8C, 0xFF},  //R 18
 {0xFF, 0x9C, 0x6E, 0x6E, 0x6E, 0xB1, 0xFF},  //S 19
 {0xFF, 0x7F, 0x7F, 0x00, 0x7F, 0x7F, 0xFF},  //T 20
 {0xFF, 0x01, 0xFE, 0xFE, 0xFE, 0x01, 0xFF},  //U 21
 {0xFF, 0x03, 0xFE, 0xFE, 0xFE, 0x03, 0xFF},  //V 22
 {0xFF, 0x00, 0xFD, 0xFB, 0xFD, 0x00, 0xFF},  //W 23
 {0xFF, 0x38, 0xD7, 0xEF, 0xD7, 0x38, 0xFF},  //X 24
 {0xFF, 0x3F, 0xDF, 0xE0, 0xDF, 0x3F, 0xFF},  //Y 25
 {0xFF, 0x78, 0x76, 0x6E, 0x5E, 0x3E, 0xFF},  //Z 26
 {0xFF, 0x81, 0x7A, 0x76, 0x6E, 0x81, 0xFF},  //0 27
 {0xFF, 0xFF, 0xDF, 0xBF, 0x00, 0xFF, 0xFF},  //1 28
 {0xFF, 0xBC, 0x7A, 0x76, 0x6E, 0x9E, 0xFF},  //2 29
 {0xFF, 0xBD, 0x7E, 0x6E, 0x6E, 0x91, 0xFF},  //3 30
 {0xFF, 0x07, 0xF7, 0xC0, 0xF7, 0xF7, 0xFF},  //4 31
 {0xFF, 0x0E, 0x6E, 0x6E, 0x6E, 0x71, 0xFF},  //5 32
 {0xFF, 0x81, 0x6E, 0x6E, 0x6E, 0xF1, 0xFF},  //6 33
 {0xFF, 0x7F, 0x7C, 0x73, 0x4F, 0x3F, 0xFF},  //7 34
 {0xFF, 0x91, 0x6E, 0x6E, 0x6E, 0x91, 0xFF},  //8 35
 {0xFF, 0x9D, 0x6E, 0x6E, 0x6E, 0x81, 0xFF},  //9 36
 {0xFF, 0xFF, 0x02, 0x02, 0xFF, 0xFF, 0xFF},  //! 37
 {0xFF, 0x67, 0x5A, 0x5A, 0xBB, 0xFF, 0xFF},  //? 38
 {0xFF, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xFF},  //- 39
 {0xFF, 0xEF, 0xEF, 0x83, 0xEF, 0xEF, 0xFF},  //+ 40
 {0xFF, 0xAB, 0xC7, 0x01, 0xC7, 0xAB, 0xFF},  //* 41
 {0xFF, 0xFF, 0xFF, 0xD7, 0xD7, 0xFF, 0xFF},  //: 42
 {0xFF, 0xFF, 0xFE, 0xFD, 0xD7, 0xFF, 0xFF},  //, 43
 {0xFF, 0xFF, 0xFC, 0xFC, 0xD7, 0xFF, 0xFF},  //. 44
 {0xFF, 0xDD, 0x9E, 0xF2, 0x9E, 0xDD, 0xFF},  //Smiley 45
 {0xFF, 0xC7, 0x83, 0xC1, 0x83, 0xc7, 0xFF},  //Heart  46
 {0xFF, 0xFF, 0xC3, 0xBD, 0x7E, 0xFF, 0xFF},  // ( 47
 {0xFF, 0xFF, 0x7E, 0xBD, 0xC3, 0xFF, 0xFF},  // ) 48
 {0xFF, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xFF},  // = 49

 };  

 // unsigned char word [MAXLEN];

 unsigned int PHRASELENGTH = 0;

/******************************************************************************
 * Main Routine
 *****************************************************************************/
void run_text (void)
{

  DDRC = 0x04;  /* set direction for the Latche Enable (LE) PortC.2 on the 
                 eStick to output */
  PORTC = 0x04; /* make the Latch transparent */
  DDRB = 0xFF;  /* set Port PORTB to output */
  DDRD &= ~(1<<PD5);
  PORTD |= (1<<PD5);

  unsigned char state=0,oldstate=0, actchar=0, state_debounce=0, mode=0;
  unsigned char bit=0,bitdir=0;
  unsigned int timestamp=0,p1=0,p2=0,cycletime=50;
  unsigned int startpos=0, dir=0,pos=0, bittime=0;

    while(1)
    {
       if (mode)
	   {
          actchar=eeprom_read_byte((unsigned char *)((startpos+pos)/CHARWIDTH));

	      if (dir==2) PORTB = characters[actchar][(startpos+pos)%CHARWIDTH]; 
		  else PORTB = 0xFF;
          _delay_loop_2(DELAYTIME*2);
		
	   }   
	   else
	   {
	  	  PORTB=~(1<<bit);
		  _delay_loop_2(DELAYTIME);
		  if (bittime++>70)
		  {
		     bittime=0;
		     if (bitdir) { if (bit<7) bit++; else bitdir=0;}
		     else { if (bit>0) bit--; else bitdir=1;}
		  }
	   }
    
	   state= PIND & (1<<PD5);
	   if (oldstate!=state) state_debounce++; else state_debounce=0;

       if (state_debounce > 10)
	   {
		    if (oldstate && (!state)) 
    	    { 
			   cycletime=timestamp;

	   	  	   p1=(unsigned int)  (timestamp*14/20);     
	   		   p2=(unsigned int)  (timestamp*2/20);      

	   		   timestamp=0; 
	   		   
			   startpos+=SCROLLSPEED;
	   		   if (startpos>=PHRASELENGTH*CHARWIDTH-DISPLENGTH*CHARWIDTH)  startpos=0; 
    	    }
     
	 	    oldstate = state;
	   }
		 
 	 
	   if (timestamp==p1)  { pos=0; dir=1; }
	   if (timestamp==p2)  { pos=DISPLENGTH*CHARWIDTH; dir=2; }

       if (dir==1) { if (pos<DISPLENGTH*CHARWIDTH) pos++; else dir=0; }
	   if (dir==2) { if (pos>0)          pos--; else dir=0; }

	   if (timestamp<300) { timestamp++; mode=1; } 
	   else { mode=0; startpos=0; pos=0; dir=0;}
	   
   }
}
 



//_____ D E F I N I T I O N S ______________________________________________

int main(void)
{

   DDRD=0x10;   // PD4= output, 0V, all others input with pullup
   PORTD=0xef;
   _delay_loop_2(1000);
   
   if (PIND & (1<<PD5))
   {

     Usb_enable_regulator();

	 #ifndef  AVRGCC
   		Wdt_off();
	 #else
   		wdt_reset();
   		Wdt_clear_flag();
   		Wdt_change_enable();
   		Wdt_stop();
	 #endif

     Clear_prescaler();
  
     usb_task_init();
     hid_task_init();

     do  usb_task();  while (hid_task()) ;
	 
   }
  

   Set_prescaler(3);
   
   for (PHRASELENGTH=0;(eeprom_read_byte((unsigned char *)PHRASELENGTH)<0xFF) && PHRASELENGTH<MAXLEN-1;PHRASELENGTH++) ;

   run_text();

   return 0;
}

